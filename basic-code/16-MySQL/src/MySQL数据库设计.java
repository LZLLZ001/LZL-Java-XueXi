/*
多表之间的关系
    一对一（1:1）不用，创建成一张表
    一对多（1:n）在从表(多方)创建一个字段作为外键指向主表(一方)的主键
    多对多（m:n）创建第三张中间表，至少两个字段分别作为外键指向各自一方的主键


数据库设计的范式：
    目前关系数据库有六种范式，后后边的范式包含前边的所有范式要求
    一般只需满足第三范式（3NF）
        1NF 原子性：表中每列不可再拆分。
        2NF 不产生局部依赖，一张表只描述一件事情
        3NF 不产生传递依赖，

第一范式（1NF）：每一列都是不可分割的原子数据项(每一列都不可再拆分)

第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码
                （在1NF基础上消除非主属性对主码的部分函数依赖）
    几个概念：
        1. 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
            例如：学号-->姓名。  （学号，课程名称） --> 分数
        2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
            例如：（学号，课程名称） --> 分数
        3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
            例如：（学号，课程名称） -- > 姓名
        4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，
            在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
            例如：学号-->系名，系名-->系主任
        5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
            例如：该表中码为：（学号，课程名称）
            * 主属性：码属性组中的所有属性
            * 非主属性：除过码属性组的属性

第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

*/


public class MySQL数据库设计 {
}
