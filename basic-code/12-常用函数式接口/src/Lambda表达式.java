/*

函数式接口:抽象方法有且只有一个抽象方法的接口,称之为函数式接口
        当然接口中可以包含其他的方法(默认,静态,私有)

函数式接口的使用:一般可以作为方法的参数和返回值类型

@FunctionalInterface注解
    作用:可以检测接口是否是一个函数式接口
        是:编译成功
        否:编译失败(接口中没有抽象方法或抽象方法的个数多余1个)


Lambda表达式作用：简化匿名内部类的写法（使用前提：此接口中只有一个抽象方法）
Lambda表达式的标准格式:
    由三部分组成:
        a.一些参数
        b.一个箭头
        c.一段代码
    格式:
        (参数列表) -> {一些重写方法的代码};
    解释说明格式:
        ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔
        ->:传递的意思,把参数传递给方法体{}
        {}:重写接口的抽象方法的方法体


Lambda表达式:是可推导,可以省略
    凡是根据上下文推导出来的内容,都可以省略书写
    可以省略的内容:
        1.(参数列表):括号中参数列表的数据类型,可以省略不写
        2.(参数列表):括号中的参数如果只有一个,那么类型和()都可以省略
        3.{一些代码}:如果{}中的代码只有一行,无论是否有返回值,都可以省略({},return,分号)
            注意:要省略{},return,分号必须一起省略

Lambda的特点:延迟加载
    使用Lambda表达式作为参数传递,仅仅是把参数传递到方法中，
    如果条件不满足，代码不会执行，所以不会存在性能的浪费。



::引用运算符
    它所在的表达式被称为方法引用
    1.通过对象名引用成员方法
        使用前提：对象名是已经存在的,成员方法也是已经存在
    2.通过类名引用静态成员方法
        类已经存在,静态成员方法也已经存在
    3.使用super引用类的成员方法
        super已经存在,父类的成员方法也已经存在
    4.使用this引用本类的成员方法
        this已经存在,本类的成员方法也已经存在
    5.类的构造器引用
    6.数组的构造器引用

*/



public class Lambda表达式 {

/*
    //定义一个方法,参数使用函数式接口MyFunctionalInterface
    public static void show(MyFunctionalInterface myInter){
        myInter.method();
    }

    public static void main(String[] args) {
        //调用show方法,方法的参数是一个接口,所以可以传递接口的实现类对象
        show(new MyFunctionalInterfaceImpl());

        //调用show方法,方法的参数是一个接口,所以我们可以传递接口的匿名内部类
        show(new MyFunctionalInterface() {
            @Override
            public void method() {
                System.out.println("使用匿名内部类重写接口中的抽象方法");
            }
        });

        //调用show方法,方法的参数是一个函数式接口,所以我们可以Lambda表达式
        show(()->{
            System.out.println("使用Lambda表达式重写接口中的抽象方法");
        });

        //简化Lambda表达式
        show(()-> System.out.println("使用Lambda表达式重写接口中的抽象方法"));
}
*/


}
