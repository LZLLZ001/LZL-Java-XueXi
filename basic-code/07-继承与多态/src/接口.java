/*
接口就是多个类的公共规范标准。
        接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。

定义一个接口的格式：
    public interface 接口名称 {
        // 接口内容
    }
    编译生成的字节码文件仍然是：.java --> .class。
    接口中可包含的内容：1常量+4方法
        1. 常量
            public static final 数据类型 常量名称 = 数据值;    //一旦使用final关键字进行修饰，说明不可改变。
            使用：接口名称.常量名称
                1. 接口当中的常量，可以省略public static final，注意：不写帮你自动填写。
                2. 常量必须进行赋值，不可改变；
                3. 常量名称完全大写，用下划线进行分隔。（推荐命名规则）

        2. 抽象方法
            public abstract 返回值类型 方法名称(参数列表);   //注意没{}
                1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract(可省略)
                2. 接口的实现类必须覆盖重写接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号。
                3. 如果没有覆盖重写接口中所有的抽象方法，那么必须是抽象类。
        3. 默认方法
            public default 返回值类型 方法名称(参数列表) {
                方法体
            }   //可以解决接口升级的问题。
                1. 接口的默认方法可以不被覆盖，通过接口实现类对象能直接调用(会自动往上找)。
                2. 被接口实现类进行覆盖则为对此方法的升级【带着default关键字】。
        4. 静态方法
            public static 返回值类型 方法名称(参数列表) {
                方法体
            }   //就是将abstract或者default换成static即可，带上方法体。
            使用：接口名称.静态方法名(参数);
            只能通过接口名称，直接调用其中的静态方法(不能通过接口实现类的对象来调用接口当中的静态方法)。
        5. 私有方法
            需要抽取一个共有方法，用来解决多个默认方法之间重复代码的问题，但是这个共有方法不应该让实现类使用，应该是私有化的。
            1. 普通私有方法，解决多个默认方法之间重复代码问题
                private 返回值类型 方法名称(参数列表) {
                    方法体
                }
            2. 静态私有方法，解决多个静态方法之间重复代码问题(静态不能直接访问非静态)
                private static 返回值类型 方法名称(参数列表) {
                    方法体
                }
               不可以直接访问接口中的默认方法
        6. 接口是没有静态代码块或者构造方法的。


接口使用步骤：
    1. 接口不能直接new使用，必须有一个“实现类”来“实现”该接口。一个类可以实现多个接口。(类与接口是多实现的)
            public class 实现类名称 implements 接口名称1，接口名称2，接口名称3 {
                // 覆盖重写所有抽象方法
            }
            如果实现类所实现的多个父接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
            存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

            实现类名称 实现类对象 = new 实现类名称();  //创建实现类的对象进行使用。

    2. 实现类可以(且只能)继承一个父类的同时实现多个接口。(类与类是单继承的，直接父类只有一个)
            public class 实现类名称 extends 父类名称 implements 接口名称1，接口名称2，接口名称3 {
                    // 覆盖重写所有抽象方法
            }
            一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。
            implements：实现   ；   extends：继承

    3. 接口能继承接口，且能继承多个。(接口与接口是多继承的)
            public interface 新接口名 extends 接口名称1, 接口名称2 {    //注意继承用的是extends
                // ...
            }



接口作为成员变量，或者方法的参数和返回值，但是实际传参时要传入实现类(而不是传入接口)
    public class 类名 {
        成员变量(属性)：
            int a;
            接口名称 接口成员对象；
        }

    使用方法：
        1. 使用单独定义的实现类
            类名.set接口成员对象(new 接口实现类());

        2. 使用匿名内部类
            接口名称 对象 = new 接口名称() {
                @Override
                }
            };
            类名.set接口成员对象(对象);

        3. 同时使用匿名内部类和匿名对象
            类名.set接口成员对象(new 接口实现类() {
                @Override
            });     //注意()和{}的位置

    A类使用接口I,然后在传参是传入B类，称为A类通过接口I依赖B类。


*/

public class 接口 {
}
