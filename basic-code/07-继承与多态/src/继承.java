/*
继承解决的问题：共性抽取
继承关系：子类is-a父类。子类包含父类

Java继承的三个特点：
    1.一个类的直接父类只能有唯一一个（接口才可以？）。
        class A extends B,C{}//错误
    2.可以多级继承。
    3.一个父类可有多个子类。

定义父类的格式：（一个普通的类定义）
    public class 父类名称 {
        // ...
    }

定义子类的格式：
    public class 子类名称 extends 父类名称 {
        // ...
    }

在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：
    直接通过子类对象访问成员变量：
        等号左边是谁，就优先用谁，没有则向上找。
    间接通过成员方法访问成员变量：
        该方法属于谁(定义在哪用哪)，就优先用谁，没有则向上找。
    重名情况下指定要用的变量：
        局部变量：         直接写成员变量名
        本类的成员变量：    this.成员变量名
        父类的成员变量：    super.成员变量名
    总结：就近原则，靠近谁用谁


在父子类的继承关系当中，创建子类对象，访问成员方法的规则：
    创建的对象是谁，就优先用谁，如果没有则向上找。
    注意事项：
        无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。

覆盖（Override）
    概念：在继承关系当中，方法的名称一样，参数列表也一样。
        方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。
            覆盖（Override）：方法的名称一样，参数列表【也一样】。
            重载（Overload）：方法的名称一样，参数列表【不一样】。

    注意事项：
        1. 必须保证父子类之间方法的名称相同，参数列表也相同。
            @Override：写在方法前面，可用来检测是不是有效的正确覆盖重写（可不写）。
        2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。
            java.lang.Object类是所有类的公共最高父类（祖宗类）
        3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。(2.3了解就行，一般2.3子类和父类都一样)
            小扩展提示：public > protected > (留空：default) > private


继承关系中，父子类构造方法的访问特点：
    1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。
    2. 子类构造可以通过super关键字来调用父类重载构造。
    3. super的父类构造调用，必须是(只能放在)子类构造方法的第一个语句，且不能一个子类构造调用多次super构造。
    总结：
        子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。

super关键字用于访问父类内容：
    1. 在子类的成员方法中，访问父类的成员变量。
        super.父类成员变量
    2. 在子类的成员方法中，访问父类的成员方法。
        super.父类成员方法
    3. 在子类的构造方法中，访问父类的构造方法。
        public Zi() {super();}

this关键字用来访问本类内容：this.xxx
    1. 在本类的成员方法中，访问本类的成员变量。
    2. 在本类的成员方法中，访问本类的另一个成员方法。
    3. 在本类的构造方法中，访问本类的另一个构造方法。
        A. this(...)调用也必须是构造方法的第一个语句，唯一一个。
        B. super和this两种构造调用，不能同时使用。


Java四种权限修饰符：
                        public  >   protected   >   不写(default)   >   private
    同一个类（我自己）        YES         YES             YES             YES
    同一个包（我邻居）        YES         YES             YES             NO
    不同包子类（我儿子）      YES         YES             NO              NO
    不同包非子类（陌生人）    YES         NO              NO              NO




在子类中升级父类过时方法：
    在覆盖函数中调用被覆盖函数
        public void fun {
            super.fun(); //先调用一次父类过时方法
            新内容；//加入新内容
        }

*/

public class 继承 {
}

