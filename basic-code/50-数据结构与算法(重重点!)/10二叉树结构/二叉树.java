/*

数组存储方式
    优点：通过下标方式访问元素，速度快。对于有序数组，可使用二分查找提高检索速度。
    缺点：未排序数组查找速度慢，有序数组插入值(按一定顺序)会整体移动，效率低。
链式存储方式
    优点：在一定程度上对数组存储方式有优化(比如：插入速度快，只需要将插入节点，链接到链表中即可， 删除效率也高)。
    缺点：查询效率仍然较低，比如(检索某个值，需要从头节点开始遍历)
树存储方式
    能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，
    既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。


二叉树：
    (1) 每个节点最多只能有两个子节点的一种形式称为二叉树。
    (2) 二叉树的子节点分为左节点和右节点。
    (3) 如果该二叉树的所有叶子节点都在最后一层，并且结点总数=2^n-1 , n为层数，则我们称为满二叉树。
    (4) 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，
        而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。

二叉树的遍历：
    前序遍历: 先输出父节点，再递归前序遍历左子树和右子树 (中左右)
    中序遍历: 先递归中序遍历左子树，再输出父节点，再遍历右子树 (左中右)
    后序遍历: 先递归后序遍历左子树，再遍历右子树，最后输出父节点 (左右中)
    小结: 3个都是从根节点开始递归遍历，看输出父节点的顺序，就确定是前序，中序还是后序

二叉树查找：前、中、后序查找：按照遍历的顺序对比，找到返回。


二叉树顺序存储：
    按照(层数从上到下，每层从左到右)的顺序将树存储到数组中
    特点:
        顺序二叉树通常只考虑完全二叉树
        第n个元素的左子节点为  2 * n + 1
        第n个元素的右子节点为  2 * n + 2
        第n个元素的父节点为  (n-1) / 2
        n : 表示二叉树中的第几个元素(从0开始编号)


线索化二叉树：

      1）n个结点的二叉链表中含有n+1【公式 2n-(n-1)=n+1】个空指针域。
        利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针
        （这种附加的指针称为"线索"，附加上指针的操作称为"线索化"）

      2）这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。
        根据线索性质的不同，可分为前、中、后序线索二叉树。

      3）一个结点在某种遍历次序下的前一个结点，称为前驱结点；后一个结点，称为后继结点。

      4）当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况:
            left 指向的是左子树，也可能是指向的前驱节点.
            right指向的是右子树，也可能是指向后继节点，
         所以在定义节点的时候加上左右两个标志位(leftType,rightType)，0表示属性指向左右子树，1表示前后节点

      5）遍历线索化二叉树时能使用线性遍历(具体见代码)，提高了效率




二叉树很多地方使用了递归操作，但是实际上每次递归到最后的实际操作都是对当前节点的操作
即左右递归时基本都是直接调用递归函数，只在当前节点操作函数中需要写处理逻辑

*/


public class 二叉树 {
}
