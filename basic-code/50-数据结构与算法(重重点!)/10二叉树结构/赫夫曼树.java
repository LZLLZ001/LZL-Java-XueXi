/*

赫夫曼树：
    给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，
    称这样的二叉树为赫夫曼树(最优二叉树)


赫夫曼树是带权路径长度最短的树，权值越大的结点离根越近。


概念：
    路径和路径长度：
        在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。
        通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1

    结点的权及带权路径长度：
        若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。
        结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积

    树的带权路径长度：WPL(weighted path length)
        树的带权路径长度规定为所有叶子结点的带权路径长度之和,
        权值越大的结点离根结点越近的二叉树才是最优二叉树。

    WPL最小的就是赫夫曼树。


构成赫夫曼树的步骤：
    1）从小到大进行排序, 将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树
    2）取出根节点权值最小的两颗二叉树
    3）组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
    4）再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复1-2-3-4 的步骤，
        直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。



赫夫曼编码算法：
    是可变字长编码(VLC)的一种，广泛地用于数据文件压缩。
    特点：
        出现次数越多的，则编码越小;
        前缀编码：字符的编码都不能是其他字符编码的前缀，即不会造成匹配的多义性;
        是无损处理方案;

    编码步奏：
        1）统计各个字符对应的个数并由小到大排序;
        2）将次数作为权值构建一颗赫夫曼树;
        3）根据赫夫曼树，给各个字符编码：向左的路径为0 向右的路径为1 (前缀编码)

    注意：树根据排序方法不同可能不太一样，这样对应的赫夫曼编码也不完全一样，
          但是wpl是一样的，都是最小的，最后生成的赫夫曼编码长度是一样的。





*/






public class 赫夫曼树 {
}
