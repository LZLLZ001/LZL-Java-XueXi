/*
排序算法：将一组数据，依指定的顺序进行排列的过程。
排序的分类：
    1) 内部排序:
        指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。
    2) 外部排序法：
        数据量过大，无法全部加载到内存中，需要借助外部存储(文件，磁盘等)进行排序。
    3) 常见的排序算法分类(见图)



时间频度T(n)：一个算法中的语句执行次数。
             统计时忽略常数项、忽略低次项。T(n)=6n^3+4n+10 -> T(n)=6n^3

算法的时间复杂度：
    算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，
    若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，
    则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n))，称Ｏ(f(n))为算法的时间复杂度

    计算时间复杂度的方法：
        (1) 用常数1代替运行时间中的所有加法常数  T(n)=3n²+7n+6  => T(n)=3n²+7n+1
        (2) 修改后的运行次数函数中，只保留最高阶项  T(n)=3n²+7n+1 => T(n) = 3n²
        (3) 去除最高阶项的系数 T(n) = 3n² => T(n) = n² => O(n²)

    注意：T(n)不同时，时间复杂度可能相同；
         时间复杂度是描述代码随着某个变量的增长带来的消耗时间(语句执行次数)增长的程度，与具体代码运行几行无关


    最坏时间复杂度: 最坏情况下的时间复杂度, 一般讨论的时间复杂度均为最坏时间复杂度
    平均时间复杂度: 指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间(一般不用)。


常见的时间复杂度：
    1) 常数阶O(1)
        只要是没有循环等复杂结构，无论代码执行了多少行都是O(1);
        执行次数与某个变量的增长无关，那么无论这类代码有多长，
        即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

    2) 对数阶O(logan)
        int i=1
        while(i<n){i=i*a}
        执行次数与变量n的关系是logan

    3) 线性阶O(n)
        for(i=1;i<n;i++)
        消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

    4) 线性对数阶O(Nlogan)
        时间复杂度为O(logan)的代码循环N遍,时间复杂度就是N*O(logan)=O(Nlogan)

    5) 平方阶O(n^2)
        把O(n)的代码再嵌套循环一遍(如：双重for循环)
        两次层循环分别为n和m，时间复杂度就变成了 O(n*m)
    6) 立方阶O(n^3)
    7) k次方阶O(n^k)
    8) 指数阶O(2^n)

    由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜Ο(2^n) ，
    随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低，尽可能避免使用指数阶的算法



空间复杂度：一般不使用
    算法在运行过程中临时占用存储空间大小的量度，也是问题规模n的函数。
    用户使用体验上看，更看重的程序执行的速度，所以一般用空间换时间。













*/
public class 排序算法 {
}
