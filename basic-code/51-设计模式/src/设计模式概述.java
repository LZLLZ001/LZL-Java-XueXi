/*
设计模式的目的：让程序(软件)，具有更好
    1) 代码重用性 (即：相同功能的代码，不用多次编写)
    2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
    3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)
    4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
    5) 使程序呈现高内聚， 低耦合的特性


设计模式七大原则:
    1. 单一职责原则：一个类(或者方法)应该只负责一项职责。
        如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，
        所以需要将类A的粒度分解为类A1、类A2。
        只有类中方法数量足够少，逻辑足够简单，可以在方法级别保持单一职责原则。

    2. 接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
        类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口
        Interface1对于类A和类C来说不是最小接口(即不会用到该接口的部分方法)，那么类B和类D必须去实现他们不需要的方法。
        则需要将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。

    3. 依赖倒转(倒置)原则：
        1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象(接口或抽象类);
        2) 抽象不应该依赖细节(具体的实现类)，细节应该依赖抽象;
        3) 中心思想是面向接口编程;
        4) 设计理念：相对于细节的多变性，抽象的东西要稳定的多，
           以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。
        5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
        6) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.
        7) 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化


        依赖：B使用了A中的东西，称为B依赖A
        依赖关系传递的三种方式：
            class D implements A { // 注意，接口作为参量实际传递的时候传递的是该接口的实现类
                public void funA() {
                    System.out.println("AAA");
                }
            }
            D d = new D();

            1) 接口传递:
                 interface B { //B接口
                    public void funB(A a); //抽象方法,接收接口
                 }
                 interface A { //A接口
                    public void funA();
                 }
                 class C implements B{ //类C通过B接口的方法，传递依赖于A
                     public void funB(A a){
                        a.funA();
                     }
                 }

                 C c = new C();
                 c.funB(d); // 即A作为B接口的参数，来给类C使用


            2) 构造方法传递:
                 interface B {
                    public void funB();
                 }
                 interface A {
                    public void funA();
                 }
                 class C implements B {
                     public A a; //成员
                     public B(A a){ // 类C通过B接口的构造器，传递依赖于A
                        this.a = a;
                     }
                     public void funB(){
                        this.a.funA();
                     }
                 }

                 C c = new C(d); // 即A作为B接口的构造器参数，来给类C使用
                 c.funB();

            3) setter方式传递:
                 interface B {
                    public void funB();
                    public void setA(A a);
                 }
                 interface A {
                    public void funA();
                 }
                 class C implements B {
                     public A a; //成员
                     public void setA(A a) { // 类C通过B接口的setter方式，传递依赖于A
                        this.a = a;
                     }
                     public void funB(){
                        this.a.funA();
                     }
                 }

                 C c = new C();
                 c.setA(d); // 即A作为B接口的setter方法参数，来给类C使用
                 c.funB();

    4. 里氏替换原则：
        继承让两个类耦合性增强了。所有引用基类的地方必须能透明地使用其子类的对象，在子类中尽量不要重写父类的方法，
        在适当的情况下，通过聚合，组合，依赖 来解决问题。
        做法：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。

    5. 开闭原则
        1) 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则
        2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)， 对修改关闭(对使用方)。 用抽象构建框架，用实现扩展细节。
        3) 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
        4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。
        个人理解：实际上就是使用抽象类

    6. 迪米特法则：
        1) 一个对象应该对其他对象保持最少的了解，核心是降低类之间的耦合。
        2) 类与类关系越密切，耦合度越大
        3) 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的
            越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内
            部。对外除了提供的public 方法，不对外泄露任何信息。
        4) 迪米特法则还有个更简单的定义：只与直接的朋友通信
        5) 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，
            我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合
            等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而
            出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量
            的形式出现在类的内部。
        个人理解：自己的方法实现写在自己类里，不要写到别的类中。

    7. 合成复用原则：
        原则是尽量使用合成/聚合的方式，而不是使用继承

     设计原则核心思想
        1) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代
        码混在一起。
        2) 针对接口编程，而不是针对实现编程。
        3) 为了交互对象之间的松耦合设计而努力


设计模式分为三种类型，共23种：
    1) 创建型模式： 单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
    2) 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
    3) 行为型模式：模版模式、命令模式、访问者模式、迭代器模式、 观察者模式、中介者模式、
        备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。

    1、创建型模式：关注的是对象的创建，将创建对象过程进行了抽象与封装，分离的对象的创建与使用。
        软件设计的过程是循序渐进的，一步一步来的。在软件设计中对象的创建和对象的使用是分开的，
        因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，
        从而能够高效地创建对象就是创建型模式要探讨的问题。这里就提供了多种创建型模式进行选择使用。

    2、结构型模式：将类或者对象结合一起形成更大的结构
        在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，
        因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。
        所以也有多种结构型模式可供开发人员选择使用。

    3、行为型模式：对在不同的对象之间划分责任和算法的抽象化。
        在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，
        那么对象的行为就会更清晰，它们之间的协作效率就会提高。

*/

public class 设计模式概述 {
}
