/*

适配器模式(Adapter Pattern)
    将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，
    让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)

    用户调用适配器转化出来的目标接口方法， 适配器再调用被适配者的相关接口方法;
    从用户的角度看不到被适配者，是解耦的,用户收到反馈结果，感觉只是和目标接口交互.


类适配器模式：
    Adapter类，通过继承 src类，实现 dst 类接口，完成src->dst的适配。
    public class Adapter extends Src implements Dst {}
        1) Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性;
        2) src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
        3) 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。


对象适配器模式
    1) 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。
        即：持有 src类，实现 dst 类接口，完成src->dst的适配
    2) 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，
       所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。使用成本更低，更灵活。

        public class Adapter implements Dst {
            private Src src; // 关联关系-聚合
            //通过构造器，传入一个 src 实例
            public VoltageAdapter(Src src) {
                this.src = src;
        }


接口适配器模式(缺省适配器模式)
    当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），
    那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求, 适用于一个接口不想使用其所有的方法的情况。

    如：I接口中有100个方法，如果B直接实现I就要在B中重写这100个方法，但B只需要使用其中1个方法，其他99个重写为空。
        设计抽象类A实现B，并为这100个方法重写了一个默认实现的空方法，B再继承A后只需要重写他要使用的这一个方法。


三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。
    类适配器：以类给到，在Adapter里，就是将src当做类，继承
    对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有
    接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现


Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。 实际开发中，实现起来不拘泥于我们讲解的三种经典形式。


SpringMvc中的HandlerAdapter，处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用
Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。
那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。
而现在扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了

*/




package 结构型模式;

public class 适配器模式 {
}
