/*

职责链模式：
    为请求创建了一个接收者对象的链。对请求的发送者和接收者进行解耦。
    职责链模式通常每个接收者都包含对另一个接收者的引用。
    如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
    使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
    将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止.


1) 将请求和处理分开，实现解耦，提高系统的灵活性
2) 简化了对象，使对象不需要知道链的结构
3) 性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般
    通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，
    超过则不允许该链建立，避免出现超长链无意识地破坏系统性能
4) 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂
5) 最佳应用场景： 有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪
    等审批流程、 Java Web中Tomcat对Encoding的处理、拦截器




实现：
    1) Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler
    2) ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者
            (即下一个处理者), 如果可以处理当前请求，则处理，
            否则就将该请求交个 后继者去处理，从而形成一个职责链
    3) Request ， 含义很多属性，表示一个请求




SpringMVC-HandlerExecutionChain 类就使用到职责链模式
    - springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等
    - 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式
    - HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不
        处理请求，只是将请求分配给链上注册处理器执行， 这是职责链实现方式,减少职责
        链本身与处理逻辑之间的耦合,规范了处理流程
    - HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应
        的拦截器.




*/

package 行为型模式;

public class 职责链模式 {
}
